'use server';
/**
 * @fileOverview This flow enables the chatbot to answer questions using an admin-provided knowledge base.
 *
 * - chatbotAnswersQuestions - A function that accepts a question string and returns an answer string.
 * - ChatbotAnswersQuestionsInput - The input type for the chatbotAnswersQuestions function.
 * - ChatbotAnswersQuestionsOutput - The return type for the chatbotAnswersQuestions function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { googleAI } from '@genkit-ai/googleai';
import { type Part } from 'genkit';

const KNOWLEDGE_COLLECTION = 'production_knowledge_base';
const KNOWLEDGE_DOCUMENT_ID = 'main_document';
const SETTINGS_COLLECTION = 'settings';
const CHATBOT_PERSONA_DOC_ID = 'chatbot_persona';
const CHATBOT_MODEL_DOC_ID = 'chatbot_model';

const ChatbotAnswersQuestionsInputSchema = z.object({
  question: z.string().describe('The question to be answered by the chatbot.'),
  userProfileInfo: z.string().optional().describe('The user\'s profile information to provide context.'),
});
export type ChatbotAnswersQuestionsInput = z.infer<typeof ChatbotAnswersQuestionsInputSchema>;

const ChatbotAnswersQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer generated by the chatbot.'),
});
export type ChatbotAnswersQuestionsOutput = z.infer<typeof ChatbotAnswersQuestionsOutputSchema>;

export async function chatbotAnswersQuestions(input: ChatbotAnswersQuestionsInput): Promise<{ stream: AsyncGenerator<Part>; response: Promise<void> }> {
  return chatbotAnswersQuestionsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'chatbotAnswersQuestionsPrompt',
  input: {schema: z.object({
    question: z.string(),
    knowledgeBase: z.string().optional(),
    userProfileInfo: z.string().optional(),
    persona: z.string().optional(),
  })},
  output: {schema: ChatbotAnswersQuestionsOutputSchema},
  prompt: `{{#if persona}}
You MUST adopt the following persona and follow all instructions within it:
<persona>
{{{persona}}}
</persona>
{{else}}
You are a helpful chatbot for a service called M-Health. Your purpose is to provide helpful information about health and wellness.
{{/if}}

Your primary goal is to answer questions using the provided knowledge base. However, you can also engage in normal conversation.

1.  **Prioritize the Knowledge Base**: First, check if the user's question can be answered using the information in the "Knowledge Base" section below. If it can, base your answer ONLY on that information.
2.  **Handle General Conversation**: If the user's question is conversational (e.g., "how are you?") or about a topic not covered in the knowledge base, you may use your general knowledge to answer.
3.  **Safety First**: If the question is about a medical topic that is NOT in the knowledge base, you MUST state that you do not have information on that topic and suggest the user consult a healthcare professional. Do not use your external knowledge for medical advice.

{{#if userProfileInfo}}
You should also consider the following information about the user to personalize your answer:
---
User Profile: {{{userProfileInfo}}}
---
{{/if}}

Knowledge Base:
---
{{{knowledgeBase}}}
---

User's Question: {{{question}}}`,
});

async function getKnowledgeBaseContent(): Promise<string> {
    try {
        const knowledgeDocRef = doc(db, KNOWLEDGE_COLLECTION, KNOWLEDGE_DOCUMENT_ID);
        const knowledgeDoc = await getDoc(knowledgeDocRef);

        if (knowledgeDoc.exists()) {
            return knowledgeDoc.data().content || '';
        }
        return '';
    } catch (error) {
        console.error("Error fetching knowledge base:", error);
        return '';
    }
}

async function getChatbotPersonaContent(): Promise<string> {
    try {
        const personaDocRef = doc(db, SETTINGS_COLLECTION, CHATBOT_PERSONA_DOC_ID);
        const personaDoc = await getDoc(personaDocRef);

        if (personaDoc.exists()) {
            return personaDoc.data().persona || '';
        }
        return '';
    } catch (error) {
        console.error("Error fetching chatbot persona:", error);
        return '';
    }
}

async function getChatbotModelName(): Promise<string> {
    try {
        const modelDocRef = doc(db, SETTINGS_COLLECTION, CHATBOT_MODEL_DOC_ID);
        const modelDoc = await getDoc(modelDocRef);

        if (modelDoc.exists() && modelDoc.data().model) {
            return modelDoc.data().model;
        }
        return 'gemini-1.5-flash-latest'; // Fallback to default
    } catch (error) {
        console.error("Error fetching chatbot model:", error);
        return 'gemini-1.5-flash-latest';
    }
}

const chatbotAnswersQuestionsFlow = ai.defineFlow(
  {
    name: 'chatbotAnswersQuestionsFlow',
    inputSchema: ChatbotAnswersQuestionsInputSchema,
    outputSchema: z.any(),
  },
  async (input) => {
    const [knowledgeBase, persona, modelName] = await Promise.all([
        getKnowledgeBaseContent(),
        getChatbotPersonaContent(),
        getChatbotModelName()
    ]);
    
    const {stream, response} = ai.generate({
        prompt: prompt,
        model: googleAI.model(modelName),
        input: {
            question: input.question,
            userProfileInfo: input.userProfileInfo,
            knowledgeBase: knowledgeBase || 'No knowledge base provided.',
            persona: persona || '',
        },
        stream: true,
    });

    return { stream, response: response.then(() => {}) };
  }
);
